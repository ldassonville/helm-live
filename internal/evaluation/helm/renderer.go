package helm

import (
	"context"
	"errors"
	"fmt"
	"github.com/ldassonville/helm-playground/internal/evaluation/kubeconform"
	"github.com/ldassonville/helm-playground/internal/workspace"
	"github.com/rs/zerolog/log"
	"github.com/yannh/kubeconform/pkg/config"
	"github.com/yannh/kubeconform/pkg/resource"
	"helm.sh/helm/v3/pkg/cli/values"
	"helm.sh/helm/v3/pkg/release"
	"os"
	"time"
)

const validationError = "values don't meet the specifications of the schema(s) in the following chart(s)"

func NewRenderer(
	wks *workspace.Workspace,
) *Renderer {

	return &Renderer{
		wks: wks,
	}
}

type Renderer struct {
	wks *workspace.Workspace
}

type ValueFile struct {
	Name   string `json:"name,omitempty"`
	Data   string `json:"data,omitempty"`
	Ref    string `json:"ref,omitempty"`
	Status string `json:"status,omitempty"`
}

type Values struct {
	Data string `json:"data,omitempty"`
}

type Render struct {
	Status        string    `json:"status,omitempty"`
	ExecutionTime time.Time `json:"executionTime,omitempty"`

	// Rendered manifests
	Manifests []*Manifest    `json:"manifests,omitempty"`
	Errors    []*RenderError `json:"errors,omitempty"`

	Values       *Values      `json:"values,omitempty"`
	ValueFiles   []*ValueFile `json:"valueFiles,omitempty"`
	MergedValues *Values      `json:"mergedValues,omitempty"`
}

// Render the chart
func (sr *Renderer) Render(ctx context.Context, valuesFile string) *Render {

	builder := NewRenderBuilder()

	log.Info().Msgf("chart resolved : %s", sr.wks.Path)

	namespace := ""
	chartPath := sr.wks.Path

	// Create the helm client
	helmcli, err := NewLocalHelm(namespace)
	if err != nil {
		log.Err(err).Msgf("unable to instantiate helm")
		return builder.
			AddError(errors.New("unable to instantiate helm")).
			Build()
	}

	vals := values.Options{}

	vals.ValueFiles = append(vals.ValueFiles, valuesFile)

	if err = os.Chdir(chartPath); err != nil {
		return builder.
			AddError(errors.New(fmt.Sprintf("unable change directory %v", err))).
			Build()
	}

	// Load the values generated by the chart
	mergedValues, err := GetMergedValues(vals)
	if err != nil {
		builder.AddError(err)
	} else {
		builder.SetMergedValues(mergedValues)
	}

	// Evaluate the chart
	chartRelease, err := helmcli.Template(chartPath, "chart-release-eval", vals)
	if err != nil {

		builder.AddError(err)
	}

	return sr.buildReleaseRender(chartRelease, builder)
}

func (sr *Renderer) buildReleaseRender(release *release.Release, builder *renderBuilder) *Render {

	if release == nil {
		return builder.Build()
	}

	// Load the manifests generated by the chart
	manifests, err := LoadYAMLManifests(release.Manifest)
	if err != nil {
		builder.
			AddError(errors.New(fmt.Sprintf("fail to load manifests : %v", err)))
	}

	validator, err := kubeconform.Validate(config.Config{
		OutputFormat: "text",
	})
	if err != nil {
		builder.
			AddError(errors.New(fmt.Sprintf("fail to load manifests : %v", err)))
	} else {
		for _, manifest := range manifests {
			res := resource.Resource{Path: fmt.Sprintf("%s-%s.yaml", manifest.Name, manifest.Kind), Bytes: []byte(manifest.Content)}
			validationRes := validator.ValidateResource(res)
			log.Info().Msgf("manifest  : %s", validationRes)
		}
	}

	return builder.
		SetStatus(string(release.Info.Status)).
		AddManifests(manifests).
		Build()

}
