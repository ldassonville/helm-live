package helm

import (
	"context"
	"errors"
	"fmt"
	"github.com/ldassonville/helm-live/internal/evaluation/kubeconform"
	"github.com/ldassonville/helm-live/internal/workspace"
	"github.com/rs/zerolog/log"
	"github.com/yannh/kubeconform/pkg/resource"
	"github.com/yannh/kubeconform/pkg/validator"
	"helm.sh/helm/v3/pkg/cli/values"
	"helm.sh/helm/v3/pkg/release"
	"os"
	"strings"
	"time"
)

const validationError = "values don't meet the specifications of the schema(s) in the following chart(s)"

func NewRenderer(
	wks *workspace.Workspace,
) *Renderer {

	return &Renderer{
		wks: wks,
	}
}

type Renderer struct {
	wks *workspace.Workspace
}

type ValueFile struct {
	Name   string `json:"name,omitempty"`
	Data   string `json:"data,omitempty"`
	Ref    string `json:"ref,omitempty"`
	Status string `json:"status,omitempty"`
}

type Values struct {
	Data string `json:"data,omitempty"`
}

type Info struct {
	Status        string    `json:"status,omitempty"`
	ExecutionTime time.Time `json:"executionTime,omitempty"`
}

type Render struct {

	// Render information
	Info *Info `json:"info,omitempty"`

	// Chart
	ChartPath string `json:"chartPath,omitempty"`
	ChartName string `json:"chartName,omitempty"`

	// Unprocessed manifest content
	RawManifest string `json:"rawManifest,omitempty"`

	Errors []*RenderError `json:"errors,omitempty"`

	Sources []*SourceFile `json:"sources,omitempty"`

	Values       *Values      `json:"values,omitempty"`
	ValueFiles   []*ValueFile `json:"valueFiles,omitempty"`
	MergedValues *Values      `json:"mergedValues,omitempty"`
}

type SourceFile struct {
	Source    string      `json:"source,omitempty"`
	Manifests []*Manifest `json:"manifests,omitempty"`
}

type RendererConfig struct {
	ValuesFile      string
	SchemaLocations []string
}

// Render the chart
func (sr *Renderer) Render(ctx context.Context, rendererConfig *RendererConfig) *Render {

	builder := NewRenderBuilder()

	log.Info().Msgf("chart resolved : %s", sr.wks.Path)

	namespace := ""
	chartPath := sr.wks.Path

	// Create the helm client
	helmcli, err := NewLocalHelm(namespace)
	if err != nil {
		log.Err(err).Msgf("unable to instantiate helm")
		return builder.
			AddError(errors.New("unable to instantiate helm")).
			Build()
	}

	vals := values.Options{}

	vals.ValueFiles = append(vals.ValueFiles, rendererConfig.ValuesFile)

	if err = os.Chdir(chartPath); err != nil {
		return builder.
			AddError(errors.New(fmt.Sprintf("unable change directory %v", err))).
			Build()
	}

	// Load the values generated by the chart
	mergedValues, err := GetMergedValues(vals)
	if err != nil {
		builder.AddError(err)
	} else {
		builder.SetMergedValues(mergedValues)
	}

	// Evaluate the chart
	chartRelease, err := helmcli.Template(chartPath, "chart-release-eval", vals)
	if err != nil {
		builder.AddError(err)
	}

	return sr.buildReleaseRender(chartRelease, builder, rendererConfig)
}

func (sr *Renderer) buildReleaseRender(release *release.Release, builder *renderBuilder, config *RendererConfig) *Render {

	if release == nil {
		return builder.Build()
	}

	builder.SetExecutionTime(release.Info.LastDeployed.Time)
	builder.SetRawManifest(release.Manifest)
	builder.SetChartPath(sr.wks.Path)
	builder.SetChartName(release.Chart.Name())

	// Load the manifests generated by the chart
	sources := LoadHelmYAMLManifests(release.Manifest)
	kkvalidator, err := validator.New(config.SchemaLocations, validator.Opts{Strict: true, SkipTLS: true, Debug: true})

	if err != nil {
		builder.
			AddError(errors.New(fmt.Sprintf("fail to load manifests : %v", err)))
	} else {
		for _, source := range sources {
			for _, manifest := range source.Manifests {

				res := resource.Resource{Path: fmt.Sprintf("%s-%s.yaml", manifest.Name, manifest.Kind), Bytes: []byte(manifest.Content)}
				validationRes := kkvalidator.ValidateResource(res)

				kcv := &KubeConformValidation{}
				manifest.KubeConformValidation = kcv

				switch validationRes.Status {
				case validator.Error:
					kcv.Status = "error"
				case validator.Skipped:
					kcv.Status = "skipped"
				case validator.Valid:
					kcv.Status = "valid"
				case validator.Invalid:
					kcv.Status = "invalid"
				case validator.Empty:
					kcv.Status = "empty"
				}

				if validationRes.Err != nil {

					kcv.ErrMsg = validationRes.Err.Error()

					if strings.Contains(kcv.ErrMsg, "could not find schema for ") {
						locationMsg := "locations : \n"
						for _, location := range config.SchemaLocations {
							msgLoc, err := kubeconform.GetSchemaPath(location, manifest.Kind, manifest.GroupVersionKind.Version, "master", true)
							if err != nil {
								locationMsg += fmt.Sprintf(" - %s\n", err.Error())

							} else {
								locationMsg += fmt.Sprintf(" - %s\n", msgLoc)
							}
						}

						kcv.ErrMsg += fmt.Sprintf("\n%s", locationMsg)
					}
				}

				for _, ve := range validationRes.ValidationErrors {
					kcv.ValidationErrors = append(kcv.ValidationErrors, ValidationError{
						Path: ve.Path,
						Msg:  ve.Msg,
					})
				}
			}
		}
	}

	return builder.
		SetStatus(string(release.Info.Status)).
		AddSources(sources).
		Build()

}
